
"""
Calibre creator mixins - adding creator supporting tools.
"""



from __future__ import division, absolute_import, print_function, annotations

from typing import Optional, Union

import os
import re
import pprint
from collections import OrderedDict
from copy import deepcopy
from numbers import Number

from LiuXin_alpha.constants import ALLOWED_DOC_TYPES
from LiuXin_alpha.constants import check_image_tuple

# from LiuXin.databases.row_collection import RowCollection
#
# from LiuXin.exceptions import InputIntegrityError
# from LiuXin.exceptions import LogicalError
# from LiuXin.exceptions import DatabaseIntegrityError
#
# from LiuXin.file_formats.chardet import force_encoding
#
# from LiuXin.metadata import check_isbn
# from LiuXin.metadata import string_to_authors
# from LiuXin.metadata import authors_to_sort_string
# from LiuXin.metadata.book.base import calibreMetadata
from LiuXin_alpha.metadata.constants import CREATOR_DROP_REGEX_SET, CREATOR_CATEGORIES, CREATOR_TYPES, CREATOR_TYPE_CAT_DIR, EXTERNAL_EBOOK_ID_SCHEMA, EXTERNAL_EBOOK_REKEY_SCHEME
from LiuXin_alpha.metadata.constants import INTERNAL_EBOOK_ID_SCHEMA
from LiuXin_alpha.metadata.constants import INTERNAL_EBOOK_REKEY_SCHEME
from LiuXin_alpha.metadata.constants import METADATA_NULL_VALUES
from LiuXin_alpha.metadata.standardize import standardize_id_name, standardize_creator_category, string_to_authors, standardize_lang, standardize_internal_id_name, standardize_rating_type, standardize_tag

from LiuXin_alpha.utils.localization import trans as _
from LiuXin_alpha.utils.logging import default_log

from LiuXin_alpha.utils.libraries.liuxin_six import six_string_types
from LiuXin_alpha.utils.libraries.liuxin_six import dict_iterkeys as iterkeys
from LiuXin_alpha.utils.libraries.liuxin_six import dict_iteritems as iteritems
from LiuXin_alpha.utils.libraries.liuxin_six import six_unicode

from LiuXin_alpha.metadata.containers.calibre_like_book_metadata.help_methods import BookMetadataHelpMixin


from LiuXin_alpha.errors import InputIntegrityError




class AutogeneratedCreator(Exception):
    pass



class CreatorsMethodsMixin:
    """
    Creator methods tools.
    """

    @property
    def creators(self) -> dict[str, list[str]]:
        """
        Return the creators dict for this book.

        Call to creators returns a dictionary keyed by the creator types and valued with an index of the creators
        Other calls should be made to get the embedded row data as well

        :return:
        """
        _data = object.__getattribute__(self, "_data")

        # All creators are requested - build the directory and return it
        creators_dict = dict()
        for creator_role in CREATOR_CATEGORIES:
            if creator_role in _data:
                creators_dict[creator_role] = deepcopy([creator for creator in _data[creator_role].keys()])
        return creators_dict

    def get_authors_copy(self):
        """
        Returns a copy of a list of all the author names.

        calibre compliant.
        :return:
        """
        _data = object.__getattribute__(self, "_data")
        if "authors" in _data:
            author_list = [a for a in _data["authors"].keys()]
            return deepcopy(author_list)
        return []

    def get_creators_dump(self):
        """
        Used when adding creators to a title when adding to the databases - returns a dictionary keyed with the
        creator_role and valued with a OrderedDict keyed with the
        :return:
        """
        _data = object.__getattribute__(self, "_data")
        creators_dict = dict()
        for creator_role in CREATOR_CATEGORIES:
            if creator_role in _data:
                creators_dict[creator_role] = deepcopy(_data[creator_role])
        return creators_dict

    def add_creators(self, creators):
        """
        Takes a dictionary of creators keyed by their role in producing the work.

        Adds them to the right place.
        If the value is a string, test for the presence of an '&' - if there is one splitting the string down at that
        point. If there isn't one just add the whole string.
        If the value is an iterable working through it and adding all the values as dictionary keyed.
        :param creators:
        :return:
        """
        _data = object.__getattribute__(self, "_data")
        creators = deepcopy(creators)

        for creator_role in creators:

            value = creators[creator_role]
            s_creator_role = standardize_creator_category(creator_role)

            if s_creator_role is None:
                err_str = "creator_role was standardized to None - so the creator couldn't be parsed"
                err_str = default_log.log_variables(err_str, "ERROR", ("creator_role", creator_role), ("value", value))
                raise InputIntegrityError(err_str)

            try:
                if isinstance(value, six_string_types):
                    # Try detecting the encoding and then re-encoding the string with that encoding
                    try:
                        value_encoding = force_encoding(value, verbose=False)
                        value = six_unicode(value, encoding=value_encoding)
                    except UnicodeDecodeError:
                        value = six_unicode(value, errors="ignore")
                    except TypeError:
                        # If the string is already unicode then just leave it
                        pass

                    # Remove any byte order marks that remain from the encoding guess - snip the first character
                    if value.startswith("\ufeff"):
                        value = value[1:]

                    # Filter for auto generated additions to the creators - abort if the creator is autogenerated
                    for creator_re in CREATOR_DROP_REGEX_SET:
                        if re.match(creator_re, value):
                            raise AutogeneratedCreator

                    # If & is present assume that we have a single creator
                    if "&" not in value:
                        if s_creator_role not in _data:
                            _data[s_creator_role] = OrderedDict()
                        if value not in _data[s_creator_role]:
                            _data[s_creator_role][value] = None
                        return
                    else:
                        value = string_to_authors(value)
                        value = [creator.strip() for creator in value]

                if s_creator_role not in _data:
                    _data[s_creator_role] = OrderedDict()
                for creator_name in value:
                    creator_name = six_unicode(creator_name)
                    if creator_name not in _data[s_creator_role]:
                        _data[s_creator_role][creator_name] = None

            except AutogeneratedCreator:
                continue

    def update_creators(self, creators_dict):
        """
        Update the internal creators store with a creators_dict

        :param creators_dict:
        :type creators_dict: A dictionary of OrderedDicts - keyed with the role of the creator in the work and valued
                             with an OrderedDict keyed with the name of the creator and valued with the id of that
                             creator on the databases.
                             Assumes that the creator_role has already been standardized and is suitable for immedate
                             inclusion into the databases.
        :return:
        """
        _data = object.__getattribute__(self, "_data")

        # Iterate through, updating all the creators
        for creator_role in creators_dict:
            _data[creator_role].update(creators_dict[creator_role])

    def read_creators(self, creators_dict):
        """
        Read a dictionary of creators keyed by creator name.

        Add creators to the metadata object in the form of a dict keyed with the role of the creator and values with
        either the creator name or an itterable of creator names.
        :param creators_dict:
        :return:
        """
        for creator_role in creators_dict:
            self.__setattr__(creator_role, creators_dict[creator_role])

    def _set_creator_from_normed_key(self, creator_key, value):
        """
        Return a creator key from a normalized creator key.

        :param normed_creator_key:
        :return:
        """
        _data = object.__getattribute__(self, "_data")

        if creator_key is not None:

            if creator_key in _data:
                if isinstance(value, six_string_types):

                    # Check to see if the passed values is one of those that should be ignored
                    for creator_re in CREATOR_DROP_REGEX_SET:
                        if re.match(creator_re, value):
                            return

                    for author in string_to_authors(value):
                        _data[creator_key][author] = None

                elif isinstance(value, (tuple, list)):
                    for v in value:
                        # Filter out the values of v which are in the autogenerated drop regex list
                        try:
                            for creator_re in CREATOR_DROP_REGEX_SET:
                                if re.match(creator_re, v):
                                    raise AutogeneratedCreator
                        except AutogeneratedCreator:
                            continue
                        else:
                            _data[creator_key][v] = None
                elif value is None:
                    pass
                else:
                    raise NotImplementedError("value type not recognized - type(value): {}".format(type(value)))
                return

            elif creator_key not in _data:
                _data[creator_key] = OrderedDict()
                _data[creator_key][value] = None
                return

            else:
                raise NotImplementedError("This position should never be reached")
