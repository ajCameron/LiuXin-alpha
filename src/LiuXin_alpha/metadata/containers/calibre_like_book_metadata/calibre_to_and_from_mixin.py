
"""
Methods to produce and produce from calibre metadata objects.
"""


from __future__ import division, absolute_import, print_function, annotations

from typing import Optional, Union

import os
import re
import pprint
from collections import OrderedDict
from copy import deepcopy
from numbers import Number

from LiuXin_alpha.constants import ALLOWED_DOC_TYPES
from LiuXin_alpha.constants import check_image_tuple

# from LiuXin.databases.row_collection import RowCollection
#
# from LiuXin.exceptions import InputIntegrityError
# from LiuXin.exceptions import LogicalError
# from LiuXin.exceptions import DatabaseIntegrityError
#
# from LiuXin.file_formats.chardet import force_encoding
#
# from LiuXin.metadata import check_isbn
# from LiuXin.metadata import string_to_authors
# from LiuXin.metadata import authors_to_sort_string
# from LiuXin.metadata.book.base import calibreMetadata
from LiuXin_alpha.metadata.constants import CREATOR_DROP_REGEX_SET, CREATOR_CATEGORIES, CREATOR_TYPES, CREATOR_TYPE_CAT_DIR, EXTERNAL_EBOOK_ID_SCHEMA, EXTERNAL_EBOOK_REKEY_SCHEME
from LiuXin_alpha.metadata.constants import INTERNAL_EBOOK_ID_SCHEMA
from LiuXin_alpha.metadata.constants import INTERNAL_EBOOK_REKEY_SCHEME
from LiuXin_alpha.metadata.constants import METADATA_NULL_VALUES
from LiuXin_alpha.metadata.standardize import standardize_id_name, standardize_creator_category, string_to_authors, standardize_lang, standardize_internal_id_name, standardize_rating_type, standardize_tag

from LiuXin_alpha.utils.localization import trans as _
from LiuXin_alpha.utils.logging import default_log

from LiuXin_alpha.utils.libraries.liuxin_six import six_string_types
from LiuXin_alpha.utils.libraries.liuxin_six import dict_iterkeys as iterkeys
from LiuXin_alpha.utils.libraries.liuxin_six import dict_iteritems as iteritems
from LiuXin_alpha.utils.libraries.liuxin_six import six_unicode

from LiuXin_alpha.metadata.containers.calibre_like_book_metadata.help_methods import BookMetadataHelpMixin


from LiuXin_alpha.errors import InputIntegrityError

from LiuXin_alpha.metadata.containers.calibre_like_book_metadata.calibre_identifiers_mixin import IdentifiersMethodsMixin
from LiuXin_alpha.metadata.containers.calibre_like_book_metadata.calibre_creators_mixin import CreatorsMethodsMixin, AutogeneratedCreator
from LiuXin_alpha.metadata.containers.calibre_like_book_metadata.calibre_files_mixin import FileMethodsMixin
from LiuXin_alpha.metadata.containers.calibre_like_book_metadata.calibre_covers_mixin import CoverMethodsMixin
from LiuXin_alpha.metadata.containers.calibre_like_book_metadata.calibre_ratings_mixin import RatingsMethodsMixin


class ToAndFromCalibreMetadataMixin:
    """
    Methods to make metadata from calibre objects and visa versa.
    """

    @classmethod
    def from_calibre(cls, calibre_md) -> "CalibreLikeLiuXinBookMetaData":
        """
        Returns a MetaData class object from a calibre metadata object.

        (or something with the same API).
        :param calibre_md: A calibre metadata object to initialize from
        :return:
        """
        title = None if not hasattr(calibre_md, "title") else calibre_md.title
        authors = None if not hasattr(calibre_md, "authors") else calibre_md.authors

        md = cls(title, authors)

        # Transfer author sort - if there is both an author sort field and a creator sort field then prefer the creator
        # sort over the author sort
        if hasattr(calibre_md, "author_sort") and hasattr(calibre_md, "creator_sort"):
            md.creator_sort = calibre_md.creator_sort if calibre_md.creator_sort else calibre_md.author_sort
        elif hasattr(calibre_md, "author_sort") and not hasattr(calibre_md, "creator_sort"):
            md.creator_sort = calibre_md.author_sort
        elif not hasattr(calibre_md, "author_sort") and hasattr(calibre_md, "creator_sort"):
            md.creator_sort = calibre_md.creator_sort
        else:
            pass

        # Transfer over the pubdate
        if hasattr(calibre_md, "pubdate"):
            md.pubdate = calibre_md.pubdate
        elif hasattr(calibre_md, "pub_date"):
            md.pubdate = calibre_md.pub_date

        # Try and transfer over the identifiers
        # EXTERNAL_EBOOK_REKEY_SCHEME is a dictionary keyed with a frozen set of known identifier names and valued with
        # the common identifier type that those identifiers should be mapped to. Trying to identify each of those id
        # types and copy them across
        for id_set in EXTERNAL_EBOOK_REKEY_SCHEME.keys():
            for id_name in id_set:
                if hasattr(calibre_md, id_name):
                    setattr(md, id_name, getattr(calibre_md, id_name))
        for id_set in INTERNAL_EBOOK_REKEY_SCHEME.keys():
            for id_name in id_set:
                if hasattr(calibre_md, id_name):
                    setattr(md, id_name, getattr(calibre_md, id_name))
        if hasattr(calibre_md, "get_identifiers"):
            calibre_md_identifiers = calibre_md.get_identifiers()
            md.set_identifiers(calibre_md_identifiers)

        # Transfer over the application_id
        if hasattr(calibre_md, "application_id"):
            md.application_id = calibre_md.application_id
        if hasattr(calibre_md, "applicationid"):
            md.application_id = calibre_md.applicationid

        # Transfer over the languages
        if hasattr(calibre_md, "language"):
            md.language = calibre_md.language
        if hasattr(calibre_md, "languages"):
            md.languages = calibre_md.languages

        # Transfer the producer - book producer is mapped to producer
        if hasattr(calibre_md, "book_producer"):
            md.producer = calibre_md.book_producer
        if hasattr(calibre_md, "producer"):
            md.producer = calibre_md.producer

        # Transfer the cover
        if hasattr(calibre_md, "cover"):
            md.cover = calibre_md.cover

        return md

    # Todo: Replace all with the is_null meth
    def to_calibre(self):
        """
        Returns a calibreMetaData version of this metadata object.
        :return:
        """
        _data = object.__getattribute__(self, "_data")

        # TITLE
        calibre_md = calibreMetadata(title=self.title, authors=None)

        # AUTHORS
        # If there are both authors and editors then the editors go first
        lx_editors = self.editors
        if lx_editors:
            calibre_md.authors = self.editors.keys() + self.authors.keys()
        else:
            calibre_md.authors = self.authors.keys()

        # AUTHOR SORT
        cs = self.creator_sort
        calibre_md.author_sort = cs if cs else authors_to_sort_string(calibre_md.authors)

        # COMMENTS
        # Includes the synopsis as it seems to be the best place to store it
        comments_vals = self.comments.keys() + self.synopses.keys()
        calibre_md.comments = ", ".join(comments_vals)

        # COVER DATA
        cover_data = self.cover_data
        if cover_data:
            calibre_md.cover_data = cover_data.keys()[0]

        # IDENTIFIERS
        # If not null transfer the first identifier of each type over to the new metadata object
        for id_type in EXTERNAL_EBOOK_ID_SCHEMA.union(INTERNAL_EBOOK_ID_SCHEMA):
            type_ids = self.__getattr__(id_type)
            if type_ids:
                calibre_md.set(field=id_type, val=type_ids.keys()[0])

        # LANGUAGES
        calibre_md.languages = self.languages

        # PUBDATE
        calibre_md.pubdate = self.pubdate

        # PUBLISHER
        publisher = self.publisher
        if publisher:
            calibre_md.publisher = publisher.keys()[0]

        # RATINGS
        if "calibre" in _data["ratings"]:
            calibre_md.rating = _data["ratings"]["calibre"]

        # SERIES AND SERIES INDEX
        series = self.series
        if series:
            md_series = series.keys()[0]
            calibre_md.series = md_series

            if md_series in self.series_index:
                calibre_md.series_index = self.series_index[md_series]

        # TAGS
        calibre_md.tags = self.tags.keys() + self.subject.keys()

        # TTITLESORT
        calibre_md.titlesort = self.titlesort

        return calibre_md
